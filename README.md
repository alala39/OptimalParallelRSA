Summary: We are going to parallelize rsa encryption on images using computation on the GPU, as well as exploring optimal scheduling methods through the halide api in c++. Initially, the encryption will consist of only the application of an RSA filter, but will progress to the shifting of pixels by an RSA key in addition to the application of the RSA filter to increase security.

Background: RSA encryption is based in modular arithmetic and discrete logs. The idea being that given two random large prime numbers p and q, we define the function z_n to return the value of an input modulo n where n = p*q. Note that x and y are multiplicative inverses modulo n if x * y == 1 mod n, and that the space defined by all numbers less than n that have multiplicative inverses mod n is equal to phi = (p-1) * (q-1). RSA encryption takes advantage of this to create two keys, a public and a private key. These two keys help to prevent the data from being compromised by a man in the middle who changes the key by intercepting it, taking the public key and then sending a different key to the recipient. The public and private keys have the relationship of public*private === 1 mod n. This means that the two keys are multiplicative inverses of each other mod n. Since the recipient of the key is only given the public key and not phi, it is very hard for the recipient to decrypt the data if they are not the intended recipient. This method is used to encrypt images in two ways: simply applying the RSA filter by raising the pixel value by the public key to encrypt and raising it to the private key to decrypt it, and then also shifting blocks of pixels around in order to scatter the image. This is done, because raising each pixel to a key value does not necessarily skew the image. It might just change the color scheme, but leave the structure of the image the same.
	
Challenges: The process of applying a filter to an image is highly parallelizable as it simply involves applying a translation to each pixel, like a convolution. The tricky part of this is optimizing the scheduling of the filter application to best make use of locality and parallelism as we want the consumer of the filtered pixels to consume as close to the application of the filter as possible in order for it to have the best possible locality. The act of shifting pixels around is more involved as it requires loads of non contiguous memory and planning of where to shift each pixel. This cannot be done concurrently and forces serialization. In order to speed up the process of applying the RSA key filter to each pixel, we plan on manipulating the ordering of tasks through the halide api for c++. This api will allow us to be able to quickly test scheduling methods in order to see which one gives us the best performance by maximizing locality and/or parallelism. In order to speed up the pixel shifting, we plan on using halide to help us test scheduling again along with testing the three methods of prefetching discussed in lecture in order to see if accesses to noncontiguous memory can be sped up when shifting occurs.

Resources: In terms of starter code, our project will mainly be started from scratch, however, the project will involve us using prewritten library code, mainly we will be using pre-existing code that allows for quick generation of random primes (p and q) in c/c++. In terms of the machine requirements, we will most likely use the gates cluster machines as we will need access primarily to GPUs (gates clusters have Nvidia gtx 1080 GPUs). Before writing code, we read a paper on the application of RSA encryption on images in parallel using cuda. That papers is cited here:
Tuteja, Vaibhav. “Image Encryption Using Parallel RSA Algorithm on Cuda.” Ijcncs.org, July 2014, www.ijcncs.org/published/volume2/issue7/p3_2-7.pdf.

Goals and Deliverables: 
	Plan to Achieve: We plan to write the most performante code possible for the parallel application of the RSA key filter to each pixel. Our deliverable will consist of an analysis of the different pipeline scheduling methods we tried out stating which one was best with graphs to support our findings. Our demo will include us running encryption and decryption on an image and showing how much faster our implementation is over the best serial implementation.
	Hope to Achieve: We hope to also be able to write a correct parallel algorithm to complete the pixel shifting of the encrypted image in parallel utilizing the same public, private key paradigm as the shifting needs to be reversible and hard to predict. We plan on demoing this feature in the same way we will demo the parallel application of the RSA encryption filter.
	-Potential Performance Expected: According to the paper we used as reference for our project inspiration, the researchers involved were able to filter 800 Mpixels/sec for a filter size of 9 pixels (3x3 convolution) with cuda. We hope to exceed this and achieve 850 Mpixels/sec as halide has been shown to slightly outperform cuda as it allows for the programmer to optimize scheduling.

Platform Choice: Our platform/language choice of c/c++, cuda, and halide is the best combination for this job as our project involves fast, parallel image processing. Cuda is a language that will allow for us to dictate computation to the GPU. Halide will be especially important for this task, as it is a domain specific language optimized for image processing and effective scheduling for such tasks. This is because halide allows for the programmer to quickly and easily iterate through the scheduling space for a given problem, while allowing the programmer to parallelize and vectorize operations relative to variables. This will allow for us to find the fastest schedule that maximizes the potential locality and parallelism possible for this task. We will also use the perf counter if possible to monitor cache misses in solution.

Schedule Tentative: 
-Week 1: Get serial implementation started (RSA encryption) and finish reading paper on parallel RSA.
	-Week 2: Finish serial implementation for RSA encryption and begin to apply it to images.
	-Week 3: Parallelize application of RSA filter and begin optimizing that parallel solution with halide.
	-Week 4 finish optimizing parallel application of RSA, test incrementally to get graph data for time of execution, and begin to work on pixel shifting.
	-Week 5 Finish pixel shifting and begin to start testing performance of pixel shifting. Begin working on write up.
	-Week 6 Try to finish optimization of pixel shifting with prefetching in order to get fastest and most secure encryption implementation. This will be our final product. Finish graphs and write up on performance characteristics of each algorithm tested and what made our fastest one the best one (discuss locality and parallelism exploited).
