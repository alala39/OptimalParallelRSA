Summary: We are going to parallelize rsa encryption on images using computation on GPUs, as well as exploring optimal scheduling methods through the halide api in c++. Initially, the encryption will consist of only the application of an RSA filter, but will progress to the pre-processing of the data (as an encryption scheme needs to be stateful or randomized in order to be secure). The preprocessing will be realized by shifting of pixels/blocks before encryption or/and by hashing the messages with a random oracle. Finally, more advanced security goals could be reached. The first security improvement would be encrypting data with a symmetric stateful/randomized cipher (harder to parallelize but improve security) using the AES protocol (the RSA protocol would then be used only for both party to agree on the symmetric key). A second improvement could be adding an authentication tag using a secure MAC (for example MD5 or SHA1) to prevent active MITM attacker. The final scheme would then reach SSL standards.

Background: RSA encryption is based on modular arithmetic and discrete logs. Specifically, the security lies on the assumption the calculating the discrete log of a value is a hard problem (that can’t be achieved by an attacker in a polynomial time). Two random large prime numbers p and q are chosen to define N = p*q. All further operation will be performed in the group Z_N. For example, x and y are multiplicative inverses modulo N if x * y == 1 mod N.
Z_N* is the space defined by all numbers in Z_N with a multiplicative inverses (all elements x respecting gcd(x, N) ==1 according to Bezout theorem). The order of Z_N* is phi = (p-1) * (q-1). RSA encryption takes advantage of this to create two keys, a public and a private key. The public key pk = (e, N) is used to encrypt data. The private key sk = (d, N)  is used to decrypt, as explain below. e and d have  to be multiplicative inverses in Z_N* (i.e e*d = 1 mod phi). p and q are not communicated. Since the factoring problem is believed to be hard, no attacker can find p and q (therefore phi) in a polynomial time. 
The encryption algorithm of a message m is Finally: E(pk, m) = m^e
The decryption algorithm for a cipher c is a trapdoor function: D(sk, c) = c^d 
Correctness : according to euler’s theorem, D(sk, (E(pk, m)) = (m^e)^d) = m^ed = m mod N (ed = phi*k + 1). Again, the security lies on the discrete log problem and the factoring problem, making impossible for an attacker to find the trapdoor d.

Challenges: The process of applying a filter to an image is highly parallelizable as it simply involves applying a translation to each pixel, like a convolution. The tricky part of this is optimizing the scheduling of the filter application to best make use of locality and parallelism as we want the consumer of the filtered pixels to consume as close to the application of the filter as possible in order for it to have the best possible locality. The act of shifting pixels around is more involved as it requires loads of non contiguous memory and planning of where to shift each pixel. This cannot be done concurrently and forces serialization. In order to speed up the process of applying the RSA key filter to each pixel, we plan on manipulating the ordering of tasks through the halide api for c++. This api will allow us to be able to quickly test scheduling methods in order to see which one gives us the best performance by maximizing locality and/or parallelism. In order to speed up the pixel shifting, we plan on using halide to help us test scheduling again along with testing the three methods of prefetching discussed in lecture in order to see if accesses to noncontiguous memory can be sped up when shifting occurs.

Resources: In terms of starter code, our project will mainly be started from scratch, however, the project will involve us using prewritten library code, mainly we will be using pre-existing code that allows for quick generation of random primes (p and q) in c/c++. In terms of the machine requirements, we will most likely use the gates cluster machines as we will need access primarily to GPUs (gates clusters have Nvidia gtx 1080 GPUs). Before writing code, we read a paper on the application of RSA encryption on images in parallel using cuda. That paper is cited here:
Tuteja, Vaibhav. “Image Encryption Using Parallel RSA Algorithm on Cuda.” Ijcncs.org, July 2014, www.ijcncs.org/published/volume2/issue7/p3_2-7.pdf.
More advanced goals: A GPU accelerated SSL proxy
https://shader.kaist.edu/sslshader/

Goals and Deliverables: 
	Plan to Achieve: We plan to write the most performance code possible for the parallel application of the RSA key filter to each pixel. Our deliverable will consist of an analysis of the different pipeline scheduling methods we tried out, stating which one was best with graphs to support our findings. Our demo will include us running encryption and decryption on an image and showing how much faster our implementation is over the best serial implementation.
	Hope to Achieve: We hope to also be able to write a correct parallel algorithm to complete the pixel shifting of the encrypted image in parallel utilizing the same public, private key paradigm as the shifting needs to be reversible and hard to predict. We plan on demoing this feature in the same way we will demo the parallel application of the RSA encryption filter.
	-Potential Performance Expected: According to the paper we used as reference for our project inspiration, the researchers involved were able to filter 800 Mpixels/sec for a filter size of 9 pixels (3x3 convolution) with cuda. We hope to exceed this and achieve 850 Mpixels/sec as halide has been shown to slightly outperform cuda as it allows for the programmer to optimize scheduling.

Platform Choice: Our platform/language choice of c/c++, cuda, and halide is the best combination for this job as our project involves fast, parallel image processing. Cuda is a language that will allow for us to dictate computation to the GPU. Halide will be especially important for this task, as it is a domain specific language optimized for image processing and effective scheduling for such tasks. This is because halide allows for the programmer to quickly and easily iterate through the scheduling space for a given problem, while allowing the programmer to parallelize and vectorise operations relative to variables. This will allow for us to find the fastest schedule that maximizes the potential locality and parallelism possible for this task. We will also use the perf counter if possible to monitor cache misses in solution.

Schedule Tentative: 
-Week 1: Get serial implementation started (RSA encryption) and finish reading paper on parallel RSA.
	-Week 2: Finish serial implementation for RSA encryption and begin to apply it to images.
	-Week 3: Parallelize application of RSA filter and begin optimizing that parallel solution with halide.
	-Week 4: finish optimizing parallel application of RSA, test incrementally to get graph data for time of execution, and begin to work on pixel shifting.
	-Week 5: Finish pixel shifting and begin to start testing performance of pixel shifting. Begin working on write up.
	-Week 6: Try to finish optimization of pixel shifting with prefetching in order to get fastest and most secure encryption implementation. This will be our final product. Finish graphs and write up on performance characteristics of each algorithm tested and what made our fastest one the best one (discuss locality and parallelism exploited).
